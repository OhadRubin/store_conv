from typing import List, Dict, Optional, Union
from pydantic import BaseModel
from datetime import datetime
import uuid


class OpenAIMessage(BaseModel):
    role: str  # The role in the conversation, e.g., "system" or "user"
    content: str  # The message content


class Request(BaseModel):
    model: str  # Model identifier, e.g., "openai/gpt-4o"
    messages: List[OpenAIMessage]  # List of messages in the conversation
    temperature: Optional[float] = None  # Temperature setting for generation
    max_tokens: Optional[int] = None  # Maximum token limit for generation
    stream: Optional[bool] = None  # Whether the response is streamed


class ChatData(BaseModel):
    timestamp: str  # Timestamp of the interaction
    request: Request  # The request details
    response: str  # Response generated by the model


class WebUIMessage(BaseModel):
    id: str  # Unique ID of the message
    parentId: Optional[
        str
    ]  # ID of the parent message (or None if it's the first message)
    childrenIds: List[str]  # List of child message IDs
    role: str  # Role of the author, either 'user' or 'assistant'
    content: str  # Content of the message
    model: str = (
        "gpt-3.5-turbo"  # Model used for this message (default 'gpt-3.5-turbo')
    )
    done: bool = (
        True  # Indicates if the message generation is complete (always True here)
    )
    context: Optional[Union[dict, None]] = None  # Context data (currently None)


class History(BaseModel):
    currentId: str  # The ID of the last processed message
    messages: Dict[
        str, WebUIMessage
    ]  # Mapping of message IDs to `WebUIMessage` objects


class Chat(BaseModel):
    history: History  # History of messages in the conversation
    models: List[
        str
    ]  # List of models used in the conversation (e.g., ['gpt-3.5-turbo'])
    messages: List[WebUIMessage]  # List of messages in the conversation
    options: dict = {}  # Options object (currently empty)
    timestamp: str  # Timestamp of the conversation
    title: str = "New Chat"  # Title of the conversation



class ConvertedChat(BaseModel):
    id: str  # Unique conversation ID
    user_id: str  # User ID (always empty in this implementation)
    title: str = "New Chat"  # Title of the conversation
    chat: Chat  # The chat object containing history and message details
    timestamp: str  # Timestamp of the conversation


def convert_openai_messages(convo) -> Chat:
    messages = []
    current_id = ""
    message_map = {}
    
    # First message has no parent
    first_message = convo.request.messages[0]
    first_id = str(uuid.uuid4())
    first_message_obj = WebUIMessage(
        id=first_id,
        parentId=None,
        childrenIds=[],
        role=first_message.role,
        content=first_message.content,
        model=convo.request.model,
        done=True,
        context=None,
    )
    messages.append(first_message_obj)
    message_map[first_id] = first_message_obj
    last_id = first_id

    # Process subsequent messages
    for openai_message in convo.request.messages[1:]:
        message_id = str(uuid.uuid4())
        new_message = WebUIMessage(
            id=message_id,
            parentId=last_id,
            childrenIds=[],
            role=openai_message.role,
            content=openai_message.content,
            model=convo.request.model,
            done=True,
            context=None,
        )
        # Update parent's childrenIds
        message_map[last_id].childrenIds.append(message_id)
        messages.append(new_message)
        message_map[message_id] = new_message
        last_id = message_id

    # Add the response message
    response_id = str(uuid.uuid4())
    response_message = WebUIMessage(
        id=response_id,
        parentId=last_id,
        childrenIds=[],
        role="assistant",
        content=convo.response,
        model=convo.request.model,
        done=True,
        context=None,
    )
    # Update parent's childrenIds
    message_map[last_id].childrenIds.append(response_id)
    messages.append(response_message)
    message_map[response_id] = response_message
    current_id = response_id

    chat = Chat(
        history=History(currentId=current_id, messages=message_map),
        models=[convo.request.model],
        messages=messages,
        options={},
        timestamp=convo.timestamp,
    )
    return chat


def validate_chat(chat: Chat) -> bool:
    # Placeholder validation logic (define actual validation as needed)
    return bool(chat)


import json


def convert_file(file_path):

    dict_chats = []
    with open(file_path, "r") as f:
        for line in f:
            chat_data = json.loads(line.strip())
            chat = ChatData(**chat_data)
            try:
                chat = convert_openai_messages(chat).model_dump()
            except json.JSONDecodeError as e:
                print(e)
                continue
            dict_chats.append(chat)
    return dict_chats
import os

def import_chat(chat):
    import requests

    url = "http://localhost:8080/api/chats/new"
    headers = {
        "Authorization": f"Bearer {os.getenv('API_KEY')}",
        "Content-Type": "application/json",
    }
    payload = {
        "chat": chat,
    }

    response = requests.post(url, headers=headers, json=payload)
    if response.status_code == 200:
        print(f"Successfully imported chat (status code: {response.status_code})")
    else:
        print(f"Failed to import chat (status code: {response.status_code})")
